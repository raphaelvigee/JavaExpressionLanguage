package com.raphaelvigee.el.NumberUtilsGenerator;

import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.TypeSpec;

import javax.lang.model.element.Modifier;
import java.io.IOException;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;

public class Generator
{
    public static void main(String[] args)
    {
        List<HelperDefinition> definitions = new ArrayList<>();
        definitions.add(HelperDefinition.arithmetic("add", "+"));
        definitions.add(HelperDefinition.arithmetic("subtract", "-"));
        definitions.add(HelperDefinition.arithmetic("multiply", "*"));
        definitions.add(HelperDefinition.arithmetic("divide", "/"));
        definitions.add(HelperDefinition.arithmetic("modulo", "%"));

        definitions.add(HelperDefinition.bitwise("and", "&"));
        definitions.add(HelperDefinition.bitwise("or", "|"));
        definitions.add(HelperDefinition.bitwise("xor", "^"));

        generate(definitions);
    }

    private static void generate(List<HelperDefinition> definitions)
    {
        List<MethodSpec> methods = new ArrayList<>();

        for (HelperDefinition definition : definitions) {
            MethodSpec.Builder builder = MethodSpec.methodBuilder(definition.name)
                    .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
                    .returns(Number.class)
                    .addParameter(Number.class, "left")
                    .addParameter(Number.class, "right");

            AtomicBoolean first = new AtomicBoolean(true);

            definition.types.forEach(type -> {
                String control = "(left instanceof $T || right instanceof $T)";

                if (first.get()) {
                    builder.beginControlFlow("if " + control, type.type, type.type);
                } else {
                    builder.nextControlFlow("else if " + control, type.type, type.type);
                }

                builder.addStatement(String.format("return left.%s() %s right.%s()", type.method, definition.operator, type.method));
                first.set(false);
            });

            builder.endControlFlow();

            builder.addStatement("throw new RuntimeException(String.format(\"Unhandled types: %s, %s\", left, right))");

            MethodSpec method = builder.build();

            methods.add(method);
        }

        TypeSpec helloWorld = TypeSpec.classBuilder("NumberUtils")
                .addModifiers(Modifier.PUBLIC)
                .addMethods(methods)
                .build();

        JavaFile javaFile = JavaFile.builder("com.raphaelvigee.el", helloWorld)
                .addFileComment("====================================\n")
                .addFileComment("== DO NOT EDIT THIS FILE MANUALLY ==\n")
                .addFileComment("====================================")
                .indent("    ")
                .build();

        try {
            PrintStream stream = new PrintStream("src/main/java/com/raphaelvigee/el/NumberUtils.java", "UTF-8");
            javaFile.writeTo(stream);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
}
